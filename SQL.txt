1. В каком порядке выполняется запрос и кратко охарактеризуй каждый оператор:

SELECT
    t1.col_2
    , COUNT(*)
    , COUNT(*) OVER()
FROM Table_1 AS t1
    INNER JOIN Table_2 AS t2
        ON t1.id =t2.id
WHERE 1 = 1 AND
    t1.col_1  > 2
GROUP BY
    t1.col_1
HAVING
    COUNT(*) > 1
QUALIFY
    COUNT(*) OVER() > 1
ORDER BY 2
LIMIT 1
                1) Сначала FROM и JOIN
                2) WHERE
                3) GROUP BY
                4) HAVING
                5) SELECT
                6) QUALIFY
                7) ORDER BY
                8) LIMIT


2. Какие виды команд ты знаешь? Назови примеры команд каждого вида и их задачу.

        1) DDL - работа со структурой таблиц: CREATE, ALTER, DROP, CREATE INDEX, TRUNCATE
        2) DML - работа с данными (вставка, удаление, выборка, изменение): SELECT, UPDATE, INSERT, DELETE, MERGE
        3) DQL - только выборка данных (подмножество DML): SELECT (ORDER BY, WHERE, GROUP BY), WITH (CTE)
        4) DCL - управление правами пользователей: GRANT, REVOKE, DENY
        5) TCL - работа с транзакциями: COMMIT, ROLLBACK, SAVEPOINT

3. Отличие DROP, DELETE, TRUNCATE.

        DROP удаляет таблицу + данные.
        DELETE удаляет указанные строки.
        TRUNCATE удаляет данные, но оставляет структуру таблицы

4. Назови основные типы данных в SQL. За основу возьми любую БД.

        1) Числовые (INTEGER, DECIMAL, BIGINT, NUMERIC)
        2) Строковые (VARCHAR, CHAR, TEXT)
        3) Дата и время (DATE, TIME, TIMESTAMP, TIMESTAMPTZ)
        4) Логический - BOOLEAN (TRUE, FALSE, NULL)
        5) Бинарные (BYTEA = изображения)

5. Назови "нестандартные" типы данных, которые ты знаешь.]

        1) Геоданные (GEOMETRY, GEOGRAPHY, POINT)
        2) Массивы (ARRAY)
        3) Перечисление (ENUM)
        4) Сетевые адреса (INET)
        5) Генерация уникальных идентификаторов (UUID)
        6) Булевые значения (Кроме TRUE, FALSE есть еще и NULL)

6. Различие строковых типов данных CHAR, VARCHAR, TEXT.

        CHAR - фиксированная длина
        VARCHAR(N) - N - длина символов, которую максимум могут иметь строки
        TEXT - многа букав

7. Назовите логические виды JOIN и для чего они нужны.

        INNER JOIN - пересечение
        CROSS JOIN - декартово произведение
        LEFT JOIN - левая таблица + недостающие значения из правой
        RIGHT JOIN - правая таблица + недостающие значения из левой
        FULL JOIN - просто все значения
        SELF JOIN - джойним таблицу на саму себя

8. Назовите физические виды JOIN и их принцип работы.

        SORT MERGE JOIN - таблицы сортируется и значения из левой проверяются на схожесть со значениями из правой
        NESTED LOOP JOIN -
        HASH JOIN -

9. Как определить, что функция является оконной?

        Ключевое слово OVER()

10.Назови виды оконных функций.

        1) Агрегатные (SUM(), AVG(), COUNT())
        2) Ранжирующие (ROW_NUMBER(), RANK(), DENSE_RANK(), NTILE(n) - разбивает результат на n-групп)
        3) Функции смещения (LAG(column, n) – значение из строки на n позиций назад
                             LEAD(column, n) – значение из строки на n позиций вперёд.
                             FIRST_VALUE(column) – первое значение в окне.
                             LAST_VALUE(column) – последнее значение в окне)

11. В чем разница между RANK и DENSE_RANK?

        RANK - ранжирование с пропусками (1,2,2,4)
        DENSE_RANK - ранжирование без пропусков (1,2,2,3)

12. Как определяется окно строк в оконной функции? Объясни, как понимаешь принцип работы оконной функции.

Оконная функция работает с набором строк, связанных с текущей строкой, — это и есть окно. Окно определяется тремя ключевыми компонентами:
        1) PARTITION BY — разбивает данные на группы (как GROUP BY, но без свёртки).
        2) ORDER BY — задаёт порядок строк внутри окна.
        3) ROWS/RANGE BETWEEN — указывает границы окна (какие строки включать в расчёт).

13. Как применял оконные функции на практике? Расскажи пример из жизни.

        Банальное ранжирование - в компании проводится оценка сотрудников,
        с помощью оконной функции можно присвоить ранг каждому сотруднику
        по его производительности в сравнение с другими

14. Как ты понимаешь, для чего нужно оптимизировать запросы?

        1) Ускорение рабочих процессов,
        2) Снижение затрат производдительности.
        3) Экономия денег
        (В BigQuery запрос, сканирующий 1 ТБ данных,
         будет стоить в 100 раз дороже, чем запрос, обрабатывающий 10 ГБ (из-за pricing model).

15. В чем различия команд EXPLAIN и EXPLAIN ANALYZE?

        EXPLAIN - план выполнения запроса (индексы, порядок выполнения, количество строк)
        EXPLAIN ANALYZE - сначала выполняет запрос и предоставляет фактические данные о его выполнении,
        вместо оценок выводятся реальные времена выполнения, кол-во обработанных строк

16. Расскажи алгоритм того, как бы ты оптимизировал запрос.

        1) Анализ запроса
        2) EXPLAIN
        3) Чекнуть индексы
        4) Оптимизация JOIN
        5) Фильтрация данных
        6) Проверка статистики
        7) Тестирование с помощью EXPLAIN ANALYZE

17. Что делают команды VACUUM, ANALYZE и VACUUM ANALYZE?

        VACUUM - очищает пространство в базе данных после удаления и обновления строк
        ANALYZE - обновляет статистику о содержимом таблиц и индексах
        VACUUM ANALYZE - все вместе, необходимо регулярно выполнять эту команду

18. Что такое spill таблиц?

        Когда данные превышают доступный объем оперативной памяти, система сохраняет данные на жесткий диск
        (например, сортировка или агрегация данных, которые требуют больших объемов памяти)
        негативно сказывается на скорость

19. Что выведет следующая команда:

    SELECT NULL + 5,
           5 - NULL,
           10 * NULL,
           10 / NULL,
           NULL / 10,
           NULL || 'какая-то прикольная фраза' (конкатенация по типу CONCAT)

           Везде будет NULL, так как, что бы вы не делали с нуллом, всегда будет нулл

20. В чем различие команд COUNT(*) и COUNT(<имя колонки>)?

            COUNT(*) считает все значение, в том числе и нуллы
            COUNT(column) считает только ненуллевые значения
            COUNT(*) быстрее и оптимизирован во многих СУБД

21. Как посчитать среднее значение? (Вопрос с подвохом)

            Если нужно учесть НУЛЛ:
                SELECT AVG(COALESCE(salary, 0)
            Если нет:
                SELECT AVG(salary)
            Можно SUM(salary) / COUNT(*) (COUNT(salary))
            в чем подвох?!

22. Какими конструкциями дополняется ORDER BY, чтобы значения NULL стояли в начале и в конце таблицы?

            NULL в начале:
                ORDER BY column1 DESC NULLS FIRST;
            NULL в конце:
                ORDER BY column1 DESC NULLS LAST;

23. Как избавиться от NULL-значений? Как ввести ограничение на вставку NULL-значений в таблице?

        Избавление от NULL-значений
            1) UPDATE table_name
               SET column_name = ''
               WHERE column_name IS NULL;
            2) DELETE FROM table_name
               WHERE column_name IS NULL;
        Ограничение на вставку NULL-значений:
            1) CREATE TABLE users (
               id SERIAL PRIMARY KEY,
               username VARCHAR(50) (!!)NOT NULL,  -- Запрещает NULL
               email VARCHAR(100) NOT NULL DEFAULT 0.00,
               age INT

24. Как разделить значение на 0, чтобы получить в ответе NULL?

        В Postgres:
            SELECT TRY_DIVIDE(10, 0)
        Можно: 10 / NULLIF(0,0)

25. Чем отличаются COUNT(*), COUNT(1), COUNT('a')?

        COUNT(*) — Подсчёт всех строк
        COUNT(1) — Подсчёт строк через константу (крч тоже самое что и COUNT(*)
        COUNT('a') - тоже самое

26. В чем отличие между группировкой и оконной функцией?

        GROUP BY Сворачивает данные в одну строку для каждой группы.
        OVER ()  Не свёртывает — сохраняет все строки исходной таблицы.
        GROUP BY Возвращает только агрегированные данные (по одной строке на группу)
        OVER() Возвращает все строки + добавленные агрегаты.
        GROUP BY - БЫСТРЕЕ
        OVER() - МЕДЛЕННЕЕ, НО ГИБЧЕ, МОЖНО НЕ ИСПОЛЬЗОВАТЬ JOIN'Ы

27. Чем отличаются результаты запросов:
    SELECT col1, COUNT(*)
    FROM t1
    GROUP BY col1;
    SELECT DISTINCT col1, COUNT(*) OVER(PARTITION BY col2)
    FROM t1

        В первом запросе результат будет одна или две строки,
        а во втором - количество строк = количество уникальных значение col1
        GROUP BY агрегирует данные, уменьшая количество строк,
        оконная функция сохраняет исходное количество строк (до применения DISTINCT), добавляя вычисленные значения.

28. Есть 2 таблицы: в первой 10 строк, во второй 100 строк.
Назови максимальное и минимальное количество возвращаемых строк при разных видах JOIN. (Данные могут быть любые.)

        INNER JOIN = мин - 0, макс - 1000
        LEFT JOIN = мин - 10, макс - 1000
        RIGHT JOIN = мин - 100, макс - 1000
        CROSS JOIN = мин - 1000, макс - 1000
        FULL JOIN = мин - 100, макс - 1110

29. Есть 2 таблицы: в первой 10 строк, во второй 100 строк.
Назови максимальное и минимальное количество возвращаемых строк при разных видах JOIN.
(Без NULL-значений и индексы не повторяются в рамках одной таблицы,
т.е. в двух таблицах данные могут как повторяться, так и нет.)

        INNER JOIN = мин - 0, макс - 10
        LEFT JOIN = мин - 10, макс - 10
        RIGHT JOIN = мин - 100, макс - 100
        CROSS JOIN = мин - 1000, макс - 1000
        FULL JOIN = мин - 100, макс - 110

30. В таблице 100 млн строк, необходимо удалить 90 млн. Как ты это сделаешь и почему?

        1) С помощью транзакции можно по 10000 строк удалять
        2) Создать новую таблицу с этими 10 млн строками, потом дропнуть старую таблицу и переименовать новую как старую
        Возможно будет минимальная блокировка
        3) Создать новую таблицу с 10 млн строками,
           Транкейтнуть старую таблицу
           В старую таблицу внести данные с новой с 10 млн строк
           Ну и дропнуть эту новую таблицу

        DELETE FROM huge_table WHERE condition - не делать, заблочит таблицу на часы!!!!!


31. Является ли следующая команда транзакцией?
    SELECT * FROM t1 WHERE id > 5;

        Нет!!!!
        Транзакция начинается с BEGIN (или START TRANSACTION в MySQL), завершается COMMIT или ROLLBACK
        НО!: В большинстве СУБД (PostgreSQL, MySQL, SQL Server)
         каждый запрос по умолчанию выполняется в режиме автокоммита,
         т.е. неявно обёрнут в транзакцию, но только на время своего выполнения.
        Сам по себе SELECT — это не транзакция, но он может выполняться в её контексте.
        Транзакция требует явного объявления (BEGIN/COMMIT)
         и включает изменяющие данные операции (INSERT, UPDATE, DELETE).

32. Есть запрос, который работает ночью и строит отчет.
Ежедневно он работал нормально и создавал отчет за 2 часа.
Сегодня утром ты пришел на работу, а отчета нет.
Смотришь свой пайплайн, а он все еще крутится на чтении запроса. Что могло произойти?

        1) Увеличение объема данных - в таблицу могли добавить лям строк за ночь
        2) Блокировки - другой процесс заблокировал таблицу
        3) Проблемы с статистикой: - оптимизатор выбрал неэффективную статистику (сделать ANALYZE)
        4) Нехватка ресурсов - перегрузка диска или кончилась память

        1) Отменить зависший запрос(
        SELECT pg_cancel_backend(pid) FROM pg_stat_activity WHERE query LIKE '%ваш_запрос%')
        2) Запустить упрощенную версию отчета (LIMIT 10000)


33. Как быстро посчитать количество строк в таблице, имеющей нормальную структуру, например, в 3 НФ,
где много колонок и пусть в ней даже JSON'овский сырец хранится? Структура таблицы пусть будет следующая:
CREATE TABLE t1
(
    id int primary key,
    col1 text,
    FK_id int NOT NULL,
    col2 text,
    col3 text,
    ....
    col100 jsonb
)

        1) Использовать системные каталоги:
            SELECT reltuples::bigint AS estimated_count
            FROM pg_class
            WHERE relname = 't1';
        2) Фильтровать по индексу:
            SELECT COUNT(*) FROM t1 WHERE id > 0;
        3) Параллельный COUNT (для PostgreSQL 9.6+)
            SET max_parallel_workers_per_gather = 4;  -- Увеличиваем параллельность
            SELECT COUNT(*) FROM t1;

34. Что такое и для чего нужен подзапрос?
    Что такое коррелируемый и не коррелируемый подзапрос? В чем отличиие СТЕ от подзапроса?

        Подзапрос - запрос внутри другого
        Коррелируемый - зависит от внешнего запроса, медленнее, выполняется для каждой строки внешнего запроса
        Некоррелируемый - не зависит от внешнего запроса, быстрее, выполняется один раз

        CTE улучшает структуру кода, особенно для сложных запросов, и поддерживает рекурсию
        СТЕ лучше читается, можно использовать несколько раз в запросе, в постгресе лучше оптимизируется.
        Используется для многоэтапных вычислений и рекурсивных задач.


35. Для чего нужна временная таблица, если есть CTE?

        СТЕ существует только внутри одного запроса, временную таблицу (TUMP TABLE) можно использовать в нескольких запросах
        Временные таблицы поддерживают индексы, ускоряющие работу
        СТЕ лучше для простых и читаемых запросов (делает код чище)
        СТЕ поддерживает рекурсию
        СТЕ не засоряет сессию лишними объектами

        Временные таблицы — для сложных ETL, множественных запросов, больших данных с индексами.
        CTE — для рекурсии, улучшения читаемости, простых промежуточных расчетов.

36. Для чего нужна команда UNION и в чем её различие с UNION ALL?
    Какая команда работает быстрее и почему?
    Какие еще операции над множествами ты знаешь и что они делают?

            UNION(ALL) используется для объединения таблиц, UNION соединяет таблицы без дубликатов,
            UNION ALL берёт всё, в том числе и дубликаты, отсюда и название
            по логике UNION ALL быстрее, так как не тратит лишнее время на обработку таблиц (удаление дубликатов)

            есть еще EXCEPT - аналогия LEFT JOIN, только наоборот, выводит строки, которые есть в первой, но не имеются во второй
            INTERSECT - типо INNER JOIN - выводит пересечение таблиц


37. Расскажи про условия в SQL.
Для чего нужна конструкция CASE, как она записывается и в каких конструкциях запроса её можно использовать?

            CASE - аналог IF в Python
            (case when условие1 then результат1 и т.д.)
            Нужна для поставления условий в запросе
            Можно юзать в SELECT, WHERE, ORDER BY, GROUP BY, HAVING, UPDATE


38. Различие между конструкциями WHERE, HAVING, QUALIFY?

            WHERE - фильтрация до группировки
            HAVING - фильтрация после группировки
            QUALIFY - фильтрация по оконным функция (в плане выполнения запроса выполняется после SELECT)
            QUALIFY - фильтрация по оконным функция (в плане выполнения запроса выполняется после SELECT)